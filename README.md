# ShellLab：构建 Unix Shell 🦀

## 实验说明文档

### 1. 实验目标 🎯

通过编写一个支持作业控制的 Unix Shell 程序，深入理解进程控制和信号处理的核心概念。

### 2. 实验概述 📝

Shell 是一个交互式命令行解释器，负责接收用户指令并执行相应程序。本实验要求实现一个简化版的 Shell，包含基本的命令解析、进程创建、信号处理、作业控制和I/O重定向功能。实验提供了骨架代码和完整的命令解析器，你需要实现核心执行逻辑和控制机制。

关于 Shell 原理和实现方法的详细指导，请参阅[实验指导文档](docs/guide.md)。

### 3. 实验要求 📋

#### 3.1 基本功能（必做）

- 命令提示符为 `"tsh> "`
- 执行命令行程序（前台或后台运行）
- 实现作业控制（bg、fg 等）
- 处理键盘信号（Ctrl+C、Ctrl+Z）
- 实现基本的 I/O 重定向（`<`、`>`）
- 回收终止的子进程

#### 3.2 内建命令

- `quit`/`exit`：终止 shell
- `jobs`：列出所有后台作业
- `bg <job>`：将一个停止状态的后台作业转为运行状态
- `fg <job>`：将一个后台作业转为前台运行
- `cd <dir>`：切换当前工作目录

#### 3.3 输出格式规范 📋

为了确保自动化测试的正确性，你的 Shell 必须严格遵循以下输出格式：

##### 作业状态消息

- 后台作业启动：`[%d] (%d) %s &`
  - 例如：`[1] (12345) /bin/ls -l &`

- 作业被信号停止：`Job [%d] (%d) stopped by signal %d`
  - 例如：`Job [1] (12345) stopped by signal 20`

- 作业被信号终止：`Job [%d] (%d) terminated by signal %d`
  - 例如：`Job [1] (12345) terminated by signal 2`

##### `jobs` 命令输出

- 运行中的作业：`[%d] (%d) Running %s`
  - 例如：`[1] (12345) Running /bin/ls -l &`

- 停止的作业：`[%d] (%d) Stopped %s`
  - 例如：`[1] (12345) Stopped /bin/ls -l`

##### `bg`/`fg` 命令输出

- `bg` 命令输出：`[%d] (%d) %s &`
  - 例如：`[1] (12345) /bin/ls -l &`

- `fg` 命令输出：不需要特殊输出，只显示命令本身

##### 错误消息

- 命令未找到：`%s: Command not found.`
  - 例如：`foo: Command not found.`

- 未指定作业：`%s command requires PID or %%jobid argument`
  - 例如：`bg command requires PID or %jobid argument`

- `bg`/`fg` 参数格式不合法：`%s: argument must be a PID or %%jobid`
  - 例如：`bg: argument must be a PID or %jobid`

- 进程不存在：`(%d): No such process`
  - 例如：`(12345): No such process`

- 作业 ID 不存在：`%%%d: No such job`
  - 例如：`%1: No such job`

### 3.4 附加任务（选做）🌟

> [!INFO]
>
> 如果你选择使用 Rust 完成本实验，可以不做选做任务。以下选做任务内容仅供学有余力的同学探索。

本实验提供多项选做任务，可以选择完成：

1. **基本管道支持** 📊
  - 实现单级管道连接（如 `cmd1 | cmd2`）
  - 相关模块：在 `shell.rs` 的 `eval` 函数中处理 `Command` 结构的 `next` 字段
2. **高级管道支持** 📈
  - 实现多级管道链（如 `cmd1 | cmd2 | cmd3 | ...`）
  - 需要先完成基本管道支持
3. **环境变量展开** 🔄
  - 实现 `$VAR` 和 `${VAR}` 格式的环境变量替换
  - 相关模块：在 `parser.rs` 中实现环境变量展开功能
4. **命令替换功能** 🔁
  - 实现 `$(command)` 格式的命令输出替换
  - 相关模块：在 `parser.rs` 中实现命令替换功能
5. **终端控制机制** 💻
  - 实现对终端的完整控制，支持运行 vim、gdb 等交互式程序
  - 实现要点：正确管理进程组、控制终端所有权、终端属性设置
  - 相关模块：在 `shell.rs` 和 `signals.rs` 中添加终端控制相关代码
6. **PATH 环境变量支持** 🔍
  - 实现通过 PATH 环境变量查找可执行文件
  - 实现要点：不需要输入完整路径即可执行在 PATH 中的程序
7. **脚本执行功能** 📜
  - 支持从文件读取并执行一系列 Shell 命令，只需实现顺序执行
  - 相关模块：在 `shell.rs` 中实现脚本执行功能
8. **环境变量支持（export）** 🔧
  - 实现 `export VAR=value` 内建命令，支持在 shell 运行期间设置环境变量
  - 设置的环境变量应当被子进程继承
  - 相关模块：在 `builtins.rs` 中添加 `export` 命令支持
9. **子 Shell（基础）** 🐣  
  - 支持通过语法 `(...)` 启动一个子 Shell，并在子进程中顺序执行其中的命令  
  - 子 Shell 中的环境修改（如 `cd`、设置变量等）不影响父 Shell  
  - 实现要点：在命令解析阶段识别 `(...)` 结构；在执行阶段，使用 `fork()` 创建新进程来执行子 Shell 命令序列
10. **子 Shell（高级）** 🚀  
  - 在基础子 Shell 的实现上，进一步支持子 Shell 作业控制、与父 Shell 管道连接等场景  
  - 需要更深入地管理进程组、终端控制与信号，使子 Shell 在前台/后台模式下都能正确处理信号  
  - 可探索让子 Shell 与父 Shell 共享部分状态（如环境变量）或实现更灵活的隔离

每项选做任务的详细要求及参考实现方法可参阅[实验指导文档](docs/guide.md)。

### 4. 文件结构与接口 🗂️

Rust 版项目采用模块化设计，文件结构如下：

```
.
├── Cargo.toml      # Rust 项目配置文件
├── src
│   ├── bin         # 测试辅助程序目录
│   │   ├── myint.rs
│   │   ├── myspin.rs
│   │   ├── mysplit.rs
│   │   └── mystop.rs
│   ├── builtins.rs # 内置命令的实现
│   ├── exec.rs     # 进程执行相关函数
│   ├── jobs.rs     # 作业控制相关函数
│   ├── main.rs     # 主函数
│   ├── parser.rs   # 命令解析相关函数
│   ├── shell.rs    # Shell 核心逻辑
│   ├── signals.rs  # 信号处理函数
│   └── utils.rs    # 工具函数
├── tests           # 测试用例目录
│   └── cases       # 包含多个测试点
└── tshref          # 参考实现
```

> [!NOTE]
> 
> 提供的代码框架更像是一个起步代码（starter code），如果你觉得现有框架限制了你的实现方式，可以根据需要直接修改代码结构，只要最终实现满足功能要求且能通过测试即可。

命令解析器提供了类似以下结构（以 Rust 风格表示）：

```rust
pub struct Command {
    /// Command and its arguments.
    pub argv: Vec<String>,
    /// Input redirection file, if any.
    pub infile: Option<String>,
    /// Output redirection file, if any.
    pub outfile: Option<String>,
    /// Append mode flag for output redirection.
    pub append: bool,
    /// Next command in a pipeline, if any.
    pub next: Option<Box<Command>>,
}

fn parse_command_line(cmdline: &str) -> Result<(Command, bool), ParseError>;
```

必做任务需要实现的主要模块和函数：

- `builtins.rs`: 内置命令的实现函数
- `shell.rs`: Shell 核心逻辑，包括命令执行
- `exec.rs`: 进程执行相关函数
- `signals.rs`: 信号处理函数
- `jobs.rs`: 作业控制相关功能

### 5. 测试方法 🧪

本实验提供了一个自动评测脚本，可以帮助你验证 Shell 实现的正确性。脚本支持多种测试模式，能够模拟用户输入、检查程序输出并提供详细反馈。

```bash
python grader.py           # 运行所有测试
python grader.py 5-jobs    # 只运行特定测试点
```

我们还提供了一个参考实现的二进制可执行文件，你可以用它来对比你的实现。

```bash
./tshref
```

#### 查看测试内容 🔍

如果想了解每个测试点具体执行的内容，可以运行：

```bash
# 查看测试会执行哪些命令但不实际运行
python grader.py -d 5-jobs
```

你也可以直接查看测试点目录内容，每个测试点包含一个 config.toml 配置文件，描述了测试的元数据和执行步骤。

#### 实用调试功能 🐛

这些功能可能也会对你有所帮助：

- **详细输出**：使用 `-v` 参数查看每个测试步骤的详细输出，包括程序的所有输出和错误信息：
  ```bash
  python grader.py -v 6-sigint
  ```
- **对比参考实现**：使用 `--compare` 参数将你的Shell输出与参考实现进行对比：
  ```bash
  python grader.py --compare 5-jobs
  ```
  脚本会显示两者输出的差异，帮你识别输出格式问题或功能缺陷。
- **重新运行失败的测试**：实现复杂功能时，可以先修复一部分问题，然后专注于剩余的失败测试：
  ```bash
  python grader.py -f
  ```
- **生成VS Code调试配置**：
  ```bash
  python grader.py --vscode
  ```
  这将为失败的测试生成VS Code调试配置，让你能够在调试器中步进执行代码，观察变量值和程序状态。

### 6. 评分标准 💯

- 基础功能实现（60%）
  - 命令执行与进程管理
  - 信号处理
  - 作业控制
  - I/O 重定向
  - 代码风格与注释

- 实现方式（20%）
  - 使用 Rust 实现（无需完成选做任务）
  - 或 C 语言实现并完成任选两项[选做任务](#33-附加任务选做)

- 实验报告与代码质量（20%）
  - 实现思路清晰
  - 关键功能分析
  - 测试结果
  - 代码结构合理
  - 注释完善
  - 错误处理充分

#### 6.1 实验评优机制 🏆

为鼓励同学们追求卓越，本实验将评选出 3 份优秀实现并进行奖励：

评选将综合考虑必做部分的完整性与正确性、代码质量（包括架构设计、可读性和可维护性）、错误处理的全面性与健壮性、功能的完善度与实用性，以及实现的创新性与技术深度。这不仅仅关注选做任务的完成数量，更注重你对 Shell 核心功能的理解深度和实现质量。

获选的优秀实现将进行公示，并在征得作者同意后开源，供同学们参考学习。同时，优秀实现的作者将直接在平时成绩中获得 5 分附加分作为奖励。

参与评优无需额外申请，所有按时提交的作业都将自动纳入评选范围。我们期待看到你富有创意且高质量的 Shell 实现，展现你对操作系统概念的深刻理解和实际应用能力。

#### 6.2 学术诚信 🔍

我们高度重视学术诚信，它是计算机科学教育的基石。我们期望你能够独立完成实验，真正掌握系统编程的核心概念和技能。

- **鼓励的行为** ✅ 
  - 与同学讨论实验的概念性问题和整体设计思路
  - 在课堂或实验课上请教助教关于实验中遇到的困难
  - 查阅官方文档、教科书和其他公开学习资源

- **禁止的行为** ❌
  - 抄袭或共享代码（包括但不限于同学之间、网络资源等）
  - 试图绕过或破解测试系统
  - 让他人代为完成作业

> [!WARNING]
> 
> 我们使用代码相似度检测工具对所有提交的代码进行检查。一旦发现抄袭或其他学术不端行为，将严格按照学校相关规定处理。

#### 6.3 关于 AI 工具使用 🤖

在现代编程环境中，ChatGPT、Claude、DeepSeek 等大型语言模型以及基于它们的工具（如 GitHub Copilot、Cursor 等）已成为许多开发者的辅助工具。我们认可这些工具在学习过程中的价值，同时也希望你合理使用它们：

1. **理解优先**：AI 工具可以帮助解释概念、提供思路或优化代码片段，但不应替代你对底层原理的理解。使用这些工具前，请先尝试自己分析问题。
2. **学习而非依赖**：将 AI 工具视为学习助手而非解决方案提供者。如果使用 AI 生成代码，确保你完全理解每一行代码的作用及其背后的原理。同时，使用 AI 工具直接生成完整的实验解决方案并提交为自己的工作是不允许的。这不仅违背了学术诚信原则，也会阻碍你获得通过实验设计的学习体验。
3. **批判性思考**：AI 生成的内容可能存在错误或不适合特定场景。建议始终以批判性思维评估其建议，并根据你对操作系统概念的理解进行调整。
5. **在报告中声明**：如果你在实验过程中使用了 AI 工具获取重要帮助，建议在实验报告中简要说明使用方式和范围。

合理使用AI工具可以增强学习效果，但最终的理解和代码实现应反映你自己的努力和思考。操作系统是计算机科学的核心领域，亲自实现这些机制将为你的技术成长奠定坚实基础。

### 7. 提交方式 📤

使用 GitHub Classroom 进行提交。请你确保所有代码已提交到你的对应仓库，GitHub Actions 会自动运行测试，其输出作为我们的评分依据。

提交截止日期：2025 年 3 月 21 日 23:59

提交内容：
1. 所有源代码文件（通过 GitHub 仓库提交）
2. 实验报告（需同时提交**源文件**和**转换后的 PDF**，详细要求请参阅[报告模板与要求](report/README.md)）

请确保在截止日期前完成最终提交。GitHub 会记录你的所有提交历史，我们将以截止日期前的最后一次提交作为最终版本进行评分。

### 8. Rust 实现注意事项 🦀

如果你选择使用 Rust 完成本实验，以下是一些可能对你有帮助的提示：

1. **安全与系统编程**：Rust 以其内存安全性而闻名，但在实现 Shell 时，你需要大量使用不安全的系统调用。请合理使用 `nix` 等包装库和 `unsafe` 代码块，平衡安全与功能实现。

2. **所有权与生命周期**：在处理进程、信号和作业控制时，Rust 的所有权系统可能带来一些挑战。请注意设计良好的数据结构，合理使用 `RefCell`、`Mutex` 等工具来管理共享状态。

3. **错误处理**：利用 Rust 的 `Result` 和 `Option` 类型进行错误处理，这将使你的 Shell 更加健壮。对于系统调用的错误，`nix` 库提供了良好的错误类型支持。

4. **跨平台兼容性**：虽然本实验主要针对 Unix-like 系统，但 Rust 的跨平台特性可以帮助你编写更通用的代码。如有需要，可以使用条件编译为不同平台提供特定实现。

5. **依赖库**：项目已经在 `Cargo.toml` 中包含了一些基础依赖库，如 `nix`、`signal-hook` 等。你可以根据需要添加更多依赖库，但请确保它们是必要的且代码体积不会过大。

# 9. 探索方向 🚀

完成基础实验后，你可能会对 Shell 的原理和实现产生更浓厚的兴趣。本节提供一些探索方向，帮助你将实验 Shell 逐步打磨成一款真正可用的现代 Shell 工具。你可以在完成必做部分后，根据自身兴趣与时间投入进行深度拓展。

## 9.1 交互体验增强 ✨

现代 Shell 的一大特色是提供丰富的交互体验。你可以考虑实现命令提示符的自定义与主题化，让用户能够展示当前时间、用户名、主机名、路径等信息，甚至支持彩色显示和动态更新。

命令自动补全是另一个极大提升效率的功能，当用户按下 Tab 键时，Shell 可以根据当前目录下的文件名或可执行命令列表进行智能补全。

更进一步，你可以实现命令历史管理，将用户执行过的命令保存到如 `~/.tsh_history` 这样的文件中，并支持类似 Ctrl+R 的历史搜索功能。

行编辑能力也是现代 Shell 的标配。在 Rust 版本中，你可以利用 `rustyline` 库，或者自己实现行编辑功能，支持光标移动、删除、撤销等操作。

语法高亮则能让用户在输入时直观地区分命令、参数、字符串等不同元素，甚至可以实时提示语法错误，大大降低使用门槛。

## 9.2 脚本与语言特性 📝

Shell 不仅是执行命令的工具，也是一种编程语言。你可以为你的 Shell 添加内建函数或脚本模块化加载功能，让用户能够编写并调用复杂的功能模块。

命令别名（alias）是另一个实用功能，让用户可以为常用命令定义简写形式，如 `alias ll='ls -l'`。

更进阶的特性包括扩展脚本语言能力，如变量定义、条件语句、循环结构等，甚至可以支持函数定义和局部变量作用域。

高级管道和进程间通信机制也是 Shell 脚本能力的重要组成部分，你可以探索如何支持多重管道、管道与子 Shell 的结合使用等。

## 9.3 系统集成扩展 🔌

真正实用的 Shell 需要与操作系统深度集成。PATH 管理与命令查找优化是一个很好的切入点，你可以支持在运行时动态添加、删除PATH中的条目，并将其持久化到配置文件。还可以使用缓存或哈希表对 PATH 下的可执行文件进行索引，加速命令查找。

持久化作业与会话恢复则是一个更具挑战性的方向，你可以研究如何将后台作业状态记录至文件，使 Shell 重启后能够重新接管先前的进程。

配置文件与插件系统可以大大增强 Shell 的可定制性和扩展性。你可以设计读取 `~/.tshrc` 这样的配置文件，在启动时加载用户的环境变量、自定义函数、别名等设置。更进一步，你可以定义插件接口，允许用户通过动态库扩展 Shell 的能力。

## 9.4 性能与安全 🛡️

对于实际使用的 Shell，性能和安全同样重要。优化 Shell 的启动速度和内存占用是一个值得探索的方向，可以考虑懒加载部分功能，避免在初始化时进行大量预加载。同时，良好的内存管理可以防止在执行复杂命令或脚本时出现内存泄漏。

在安全方面，你可以实现命令执行的权限控制和安全检查，如白名单/黑名单机制，防止执行某些高危操作。对命令执行路径和权限的严格检查则可以预防路径注入攻击。

更进一步，你可以研究如何通过 Linux 的 `seccomp` 或其他机制为命令执行提供沙盒环境，对 Shell 可执行的系统调用进行限制，在保证功能的同时提升安全性。

## 9.5 参考资源 📚

- [POSIX Shell 标准](https://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html)
  有助于理解 Shell 语法的最小通用规范和关键特性。
- [GNU Bash 参考手册](https://www.gnu.org/software/bash/manual/)
  Bash包含了大量进阶功能，如命令替换、算术表达式、扩展模式匹配等，能为自定义Shell提供借鉴。
- [Zsh 官方文档](https://zsh.sourceforge.io/Doc/)
  Zsh在交互性、可扩展性方面非常灵活，很多功能或设计理念值得学习。
- [高级 Bash 脚本指南](https://tldp.org/LDP/abs/html/)
  其中对Shell脚本的高级语法、技巧、陷阱均有说明，可以作为实现高级功能时的参考。
- [Rust 编程语言中文版](https://rustwiki.org/zh-CN/book/)
  Rust 的官方中文教程，有助于理解 Rust 的核心概念和最佳实践。
- [Rust 标准库文档](https://doc.rust-lang.org/std/index.html)
  Rust 标准库文档，有助于理解 Rust 的标准库。
- [nix 库文档](https://docs.rs/nix/latest/nix/)
  Rust 中用于系统编程的关键库，提供了对 POSIX API 的安全封装。
- [signal-hook 库文档](https://docs.rs/signal-hook/latest/signal_hook/)
  Rust 中用于捕获和处理信号的库，提供了对 POSIX 信号的封装。
